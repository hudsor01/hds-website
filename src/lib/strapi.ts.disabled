/**
 * Strapi CMS Integration
 * Connects to a Strapi backend for blog content management
 */

import qs from 'qs';

// Strapi configuration
const STRAPI_URL = process.env.NEXT_PUBLIC_STRAPI_URL || 'http://localhost:1337';
const STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;

interface StrapiAttributes {
  title: string;
  slug: string;
  excerpt: string;
  content: any; // Rich text blocks from Strapi
  publishedAt: string;
  seo?: {
    metaTitle?: string;
    metaDescription?: string;
    keywords?: string;
    metaImage?: {
      data?: {
        attributes?: {
          url: string;
          alternativeText?: string;
        };
      };
    };
  };
  author?: {
    data?: {
      attributes?: {
        name: string;
        bio?: string;
        avatar?: {
          data?: {
            attributes?: {
              url: string;
            };
          };
        };
      };
    };
  };
  category?: {
    data?: {
      attributes?: {
        name: string;
        slug: string;
      };
    };
  };
  tags?: {
    data?: Array<{
      attributes?: {
        name: string;
        slug: string;
      };
    }>;
  };
  featuredImage?: {
    data?: {
      attributes?: {
        url: string;
        alternativeText?: string;
        width?: number;
        height?: number;
      };
    };
  };
}

interface StrapiPost {
  id: number;
  attributes: StrapiAttributes;
}

interface StrapiResponse<T> {
  data: T;
  meta?: {
    pagination?: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

/**
 * Fetch helper with authentication
 */
async function fetchStrapi<T>(
  path: string,
  urlParamsObject: Record<string, any> = {},
  options: RequestInit = {}
): Promise<T> {
  try {
    // Merge default and user options
    const mergedOptions: RequestInit = {
      headers: {
        'Content-Type': 'application/json',
        ...(STRAPI_API_TOKEN && {
          Authorization: `Bearer ${STRAPI_API_TOKEN}`,
        }),
      },
      ...options,
    };

    // Build request URL
    const queryString = qs.stringify(urlParamsObject, { encodeValuesOnly: true });
    const requestUrl = `${STRAPI_URL}/api${path}${queryString ? `?${queryString}` : ''}`;

    // Trigger API call
    const response = await fetch(requestUrl, mergedOptions);
    const data = await response.json();

    if (!response.ok) {
      throw new Error(data?.error?.message || 'Failed to fetch from Strapi');
    }

    return data;
  } catch (error) {
    console.error(`Strapi fetch error for ${path}:`, error);
    throw error;
  }
}

/**
 * Get all blog posts
 */
export async function getBlogPosts(params?: {
  page?: number;
  pageSize?: number;
  sort?: string;
  filters?: any;
}): Promise<{ posts: StrapiPost[]; pagination?: any }> {
  const defaultParams = {
    populate: {
      author: {
        populate: ['avatar'],
      },
      category: true,
      tags: true,
      featuredImage: true,
      seo: {
        populate: ['metaImage'],
      },
    },
    sort: params?.sort || ['publishedAt:desc'],
    pagination: {
      page: params?.page || 1,
      pageSize: params?.pageSize || 10,
    },
    ...(params?.filters && { filters: params.filters }),
  };

  const response = await fetchStrapi<StrapiResponse<StrapiPost[]>>(
    '/blog-posts',
    defaultParams
  );

  return {
    posts: response.data,
    pagination: response.meta?.pagination,
  };
}

/**
 * Get a single blog post by slug
 */
export async function getBlogPost(slug: string): Promise<StrapiPost | null> {
  const params = {
    filters: { slug },
    populate: {
      author: {
        populate: ['avatar'],
      },
      category: true,
      tags: true,
      featuredImage: true,
      seo: {
        populate: ['metaImage'],
      },
      content: true,
    },
  };

  const response = await fetchStrapi<StrapiResponse<StrapiPost[]>>(
    '/blog-posts',
    params
  );

  return response.data?.[0] || null;
}

/**
 * Get blog categories
 */
export async function getBlogCategories() {
  const params = {
    populate: ['posts'],
    sort: ['name:asc'],
  };

  const response = await fetchStrapi<StrapiResponse<any[]>>(
    '/blog-categories',
    params
  );

  return response.data;
}

/**
 * Get blog tags
 */
export async function getBlogTags() {
  const params = {
    populate: ['posts'],
    sort: ['name:asc'],
  };

  const response = await fetchStrapi<StrapiResponse<any[]>>(
    '/blog-tags',
    params
  );

  return response.data;
}

/**
 * Search blog posts
 */
export async function searchBlogPosts(query: string) {
  const params = {
    filters: {
      $or: [
        { title: { $containsi: query } },
        { excerpt: { $containsi: query } },
        { content: { $containsi: query } },
      ],
    },
    populate: ['author', 'category', 'featuredImage'],
  };

  const response = await fetchStrapi<StrapiResponse<StrapiPost[]>>(
    '/blog-posts',
    params
  );

  return response.data;
}

/**
 * Get related posts
 */
export async function getRelatedPosts(
  currentSlug: string,
  category?: string,
  limit = 3
): Promise<StrapiPost[]> {
  const params = {
    filters: {
      slug: { $ne: currentSlug },
      ...(category && {
        category: {
          slug: category,
        },
      }),
    },
    populate: ['author', 'category', 'featuredImage'],
    pagination: {
      limit,
    },
    sort: ['publishedAt:desc'],
  };

  const response = await fetchStrapi<StrapiResponse<StrapiPost[]>>(
    '/blog-posts',
    params
  );

  return response.data;
}

/**
 * Get featured posts
 */
export async function getFeaturedPosts(limit = 3): Promise<StrapiPost[]> {
  const params = {
    filters: {
      featured: true,
    },
    populate: ['author', 'category', 'featuredImage'],
    pagination: {
      limit,
    },
    sort: ['publishedAt:desc'],
  };

  const response = await fetchStrapi<StrapiResponse<StrapiPost[]>>(
    '/blog-posts',
    params
  );

  return response.data;
}

/**
 * Helper to construct full image URL
 */
export function getStrapiImageUrl(url?: string): string {
  if (!url) return '/images/placeholder.jpg';
  if (url.startsWith('http')) return url;
  return `${STRAPI_URL}${url}`;
}

/**
 * Helper to format Strapi date
 */
export function formatStrapiDate(date: string): string {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

/**
 * Convert Strapi rich text to HTML
 * This is a simplified version - you may want to use @strapi/blocks-react-renderer
 */
export function strapiRichTextToHtml(content: any): string {
  if (!content) return '';
  
  // If content is already a string, return it
  if (typeof content === 'string') return content;
  
  // If it's Strapi blocks format, you'll need to parse it
  // This is where @strapi/blocks-react-renderer comes in handy
  return JSON.stringify(content);
}

// Export types for use in components
export type { StrapiPost, StrapiAttributes, StrapiResponse };