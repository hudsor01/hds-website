---
phase: 46-blog-content-seeding
plan: 01
type: execute
---

<objective>
Seed real blog posts into the Neon database via Neon MCP run_sql.

Purpose: Replace or supplement the 3 placeholder posts seeded in Phase 42 with real post content the user has already written. The blog schema and all Drizzle queries already exist — this is a pure data operation.
Output: Neon blog_posts table populated with real content, visible at /blog and /blog/[slug]
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/42-blog-data-strategy/42-01-SUMMARY.md
@src/lib/schemas/blog.ts
@src/lib/blog.ts

**Constraining decisions from Phase 42:**
- Seed via Neon MCP run_sql (not seed scripts — no production credentials in codebase)
- Dollar-quoted strings ($html$...$html$) for safe HTML insertion
- blog_post_tags cascade-deletes when post is deleted (safe to truncate posts first)
- Author slug: "richard-hudson", existing tags: check with SELECT before inserting

**Blog schema fields:**
- blog_authors: id (uuid), slug (text unique), name, bio, profile_image, created_at
- blog_tags: id (uuid), slug (text unique), name, description
- blog_posts: id (uuid), slug (text unique), title, excerpt, content (HTML), feature_image,
  published_at (timestamp), reading_time (int, minutes), featured (bool), published (bool),
  author_id (uuid FK → blog_authors), created_at, updated_at
- blog_post_tags: post_id FK, tag_id FK (composite PK, cascade delete)

**Routing:** /blog/[slug] — slug must match the URL-safe string in blog_posts.slug
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit current Neon blog data state</name>
  <files>None — read-only Neon MCP queries</files>
  <action>
    Use Neon MCP run_sql to query the current state of all 4 blog tables. Run these in sequence:

    1. SELECT id, slug, name FROM blog_authors;
    2. SELECT id, slug, name FROM blog_tags;
    3. SELECT id, slug, title, excerpt, published, featured, published_at FROM blog_posts ORDER BY published_at DESC;
    4. SELECT COUNT(*) FROM blog_post_tags;

    Display results clearly. This establishes baseline before any changes.
  </action>
  <verify>All 4 queries return results (no errors). Display the current row counts and titles.</verify>
  <done>User can see exactly what placeholder data exists (from Phase 42: 1 author, 3 tags, 3 posts, 3 junction rows).</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Provide real blog post content to seed into the database</action>
  <instructions>
    The current database has 3 placeholder posts from Phase 42 (shown above). I need the real blog posts you've written.

    For each post, provide:
    - **title**: Full post title
    - **slug**: URL-safe slug (e.g., "how-to-build-better-websites")
    - **excerpt**: 1-2 sentence summary for the blog listing page (150-200 chars)
    - **content**: Full post content as HTML (or markdown — I can convert)
    - **tags**: Which tags to associate (use existing ones or list new tags to create)
    - **reading_time**: Estimated read time in minutes
    - **featured**: true/false — should this appear as featured post?
    - **published_at**: Publication date (ISO format, e.g. "2026-02-01")

    Also indicate:
    - Should the 3 existing placeholder posts be DELETED before inserting, or KEPT?
    - Any new tags to add beyond the existing 3?
    - Any author profile updates (bio, profile_image URL)?

    Paste the content here directly, or share one post at a time.
  </instructions>
  <verification>User has provided all post content in a format I can translate to SQL.</verification>
  <resume-signal>Paste post content above and type "ready to seed" when done providing all posts</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Seed real posts via Neon MCP run_sql</name>
  <files>None — Neon MCP data operations only</files>
  <action>
    Using the content provided in the checkpoint, execute SQL via Neon MCP run_sql:

    **If replacing placeholder posts:**
    1. DELETE existing posts (cascade will clean blog_post_tags automatically):
       DELETE FROM blog_posts WHERE slug IN ('existing-slug-1', 'existing-slug-2', 'existing-slug-3');

    **For each new tag (if any):**
    2. INSERT INTO blog_tags (id, slug, name, description) VALUES (gen_random_uuid(), 'tag-slug', 'Tag Name', 'Description');

    **For each new post:**
    3. INSERT INTO blog_posts (id, slug, title, excerpt, content, reading_time, featured, published, published_at, author_id)
       VALUES (
         gen_random_uuid(),
         'post-slug',
         'Post Title',
         'Excerpt text',
         $html$<content goes here>$html$,
         5,
         false,
         true,
         '2026-02-01T00:00:00Z',
         (SELECT id FROM blog_authors WHERE slug = 'richard-hudson')
       );

    **For each post-tag association:**
    4. INSERT INTO blog_post_tags (post_id, tag_id)
       VALUES (
         (SELECT id FROM blog_posts WHERE slug = 'post-slug'),
         (SELECT id FROM blog_tags WHERE slug = 'tag-slug')
       );

    **Always:** Use dollar-quoting ($html$...$html$) for content containing HTML, apostrophes, or quotes.

    **After all inserts:** Verify with:
    SELECT slug, title, featured, published_at FROM blog_posts ORDER BY published_at DESC;

    Run each statement as a separate Neon MCP run_sql call (not batched in a transaction block) since the MCP tool executes individual statements.
  </action>
  <verify>
    SELECT COUNT(*) FROM blog_posts WHERE published = true;
    -- Should return the number of real posts just inserted

    SELECT p.slug, p.title, array_agg(t.name) as tags
    FROM blog_posts p
    LEFT JOIN blog_post_tags pt ON p.id = pt.post_id
    LEFT JOIN blog_tags t ON pt.tag_id = t.id
    GROUP BY p.id, p.slug, p.title;
    -- Should show posts with their tag associations
  </verify>
  <done>
    - All real posts inserted into blog_posts
    - All tag associations in blog_post_tags
    - bun typecheck passes (no code changed, but confirm build is clean)
    - /blog page shows real post titles (verifiable in dev server)
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] SELECT COUNT(*) FROM blog_posts returns expected count
- [ ] Each post has at least one tag in blog_post_tags
- [ ] No duplicate slugs (UNIQUE constraint would reject these anyway)
- [ ] bun run typecheck passes (0 TypeScript errors — no code changed, just confirm)
- [ ] bun test tests/ passes (329 tests — no regressions)
</verification>

<success_criteria>

- Real blog posts seeded into Neon blog_posts table
- Tag associations in blog_post_tags for each post
- Placeholder posts removed (if user requested)
- Zero code changes — this is purely a data operation
- All 329 existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/46-blog-content-seeding/46-01-SUMMARY.md`:

# Phase 46 Plan 01: Blog Content Seeding Summary

**[Substantive one-liner — e.g., "Seeded 5 real blog posts into Neon, replacing 3 Phase 42 placeholders"]**

## Accomplishments

- [Posts seeded: titles, slugs]
- [Tags created/used]
- [Placeholders removed if applicable]

## Files Created/Modified

- None (data-only operation)

## SQL Executed

- [Summary of INSERT/DELETE statements run via Neon MCP]

## Decisions Made

- [e.g., "Kept 2 placeholder posts, added 4 new real posts"]

## Issues Encountered

- [Problems and resolutions, or "None"]

## Next Step

Phase complete, ready for Phase 47 (Tools Index — All 14 Tools)
</output>
